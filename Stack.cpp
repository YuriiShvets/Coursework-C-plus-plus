/*
Stack.cpp
Coursework
Shvets Ju. BS-33
Implementation to class "Stack"
*/

#include "Stack.h"

Stack::Stack():head(NULL)//конструктор
{

}
//----------------------------------------------------------------
void Stack::push(Train *B)//функція для додавання елементу
{
	Element *A=new Element;//виділяємо пам'ятт під елемент
	A->next=head;//привласнюємо вказівнику на на наступний елемент вказівник на голову стека
	A->data=B;//записуємо данні
	head=A;//вказівнику на перший елемент привласнюємо адресу нового елемента 
}
//----------------------------------------------------------------
void Stack::print() const//функція для друку колекції
{
	if(head==NULL)//перевірка на порожність колекції
		cout<<"No trains found\n";//якщо стек порожній виводимо відповідне повідомлення
	for(Element *i=head; i!=NULL; i=i->next)//цикл проходить по всіх елементах стека
		i->data->print();//для кожного елемента викликається функція друку
}
//----------------------------------------------------------------
void Stack::pop()//функція видалення елемента із стека
{
	if(head!=NULL)//перевірка на порожність колекції
	{
		Element *i=head;//ініціалізуємо вказівник адресою голови стека
		head=head->next;//вказівнику на голову стека передаємо адресу наступного елемента
		delete i->data;//видиляємо данні із першого елемента
		delete i;//видаляємо перший елемент
	}
	else
	{
		system("cls");//очищуємо екран
		cout<<"No trains found\n";//виводимо повідомлення про порожність стека
		_getch();//затримка
	}
}
//----------------------------------------------------------------
void Stack::Write_to_the_file() const//функція для виводу у файл
{
	if(head==NULL)				//перевірка на порожність колекції
	{
		system("cls");//очищуємо екран
		cout<<"No trains found";//виводимо повідомлення про порожність стека
		_getch();//затримка
	}
	else
	{
		ofstream Trains("Trains.txt");//відкриваємо файл
		Element *k;//створюємо вказівник
		for(int i=0; i<Size(); i++)//цикл проходить по всіх елементах стека
		{
			if(Trains.is_open()==0)	//перевірка файла на працездатність
			{
				cout<<"failed to open file";//вивід повідомлення про неможливість відкрити файл
				_getch();//затримка
				break;//вихід із циклу
			}//End of "if(Trains.is_open()==0)"
			k=head;//привласнюємо вказівнику адресу голови стека
			for(int j=0; j<Size()-(i+1); j++)//за допомогою цього і першого циклк проходимо всі елементи від останнього до першого (чия адреса зберігається у вказівнику head)
				k=k->next;//привласнюємо вказівнику адресу наступного елемента
			if(typeid(*(k->data))==typeid(Passenger_train))//якщо об'єкт має тип пасажирського потяга
				Trains<<(*((Passenger_train*)(k->data)));//викликається перегружена операція вивода в потік об'єкта пасажирського потяга
			if(typeid(*(k->data))==typeid(Freight_train))//якщо об'єкт має тип вантажного потяга
				Trains<<(*((Freight_train*)(k->data)));//викликається перегружена операція вивода в потік обєкта вантажного потяга
		}//End of "for(int i=0; i<Size(); i++)"
		Trains.close();				//закриваємо файл
	}
	cout<<"Saved";//виводимо повідомлення про збереження колекції у файл
}
//----------------------------------------------------------------
void Stack::Read_from_the_file()//функція для введення об'єктів із потоку
{
	int k;//створюємо змінну в яку будемо виводити ідентифікатор типу потяга
	ifstream Trains ("Trains.txt");	//відкриваємо файл
	while(!Trains.eof())//поки файл не порожній
	{
		if(Trains.is_open()==0)		//перевірка файла на працездатність
		{
			cout<<"failed to open file";//вивід повідомлення про порожність стека
			_getch();//затримка
			break;//вихід з циклк
		}//End of "if(Trains.is_open()==0)"
		k=0;
		Trains>>k;//виводимо ідентифікатор типу
		if(k==1)//якщо ідентифікатор типу рівний 1
		{
			Passenger_train *B=new Passenger_train;//створюємо об'єкти пасажирського потяга
			Trains>>(*B);			//записуємо об'єкт з файлу
			push(B);//додаємо об'єкт у стек
		}//End of "if(k==1)"
		if(k==2)//якщо ідентифікатор типу рівний 2
		{
			Freight_train *B=new Freight_train;//створюємо об'єкт вантажного потяга
			Trains>>(*B);			//записуємо об'єкт з файлу
			push(B);//додаємо об'єкт у стек
		}//End of "if(k==2)"
	}//End of "while(!Trains.eof())"
	cout<<"Loaded";//виводимо повідомлення про успішне завантаження з файлу
}
//----------------------------------------------------------------
void Stack::Sort()					//Алгоритм сортування обміном(бульбашкою)
{									//Сортування відбувається відносно номере потяга
	bool check=false;//створюємо змінну яка буде служити індикатором відсортованості контейнера
	Element *buf1, *bufi, *bufn;//створюємо вказівники яким будуть передаватися адреси об'єктів
	int c;//створюємот змінну - лічільник
	while(check==false)//поки контейнер не відсортований
	{
		c=0;
		check=true;
		for(Element *i=head; i!=NULL; i=i->next)//цикл проходить по усіх елементах контейнера
		{
			if(((i->next)!=NULL)&&(((i->data)->get_number())>(((i->next)->data)->get_number())))//якщо номер потяга більший за номер наступного потяга
			{
				bufn=i->next;				//
				buf1=i;						//
				buf1->next=(i->next)->next;	//
				i=bufn;						//
				i->next=buf1;				// міняємо об'єкти місцями
				if(c==0)					//
					head=i;					//
				if(c>0)						//
					bufi->next=i;			//
				check=false;
			}//End of "if(((i->next)!=NULL)&&(((i->data)->get_number())>(((i->next)->data)->get_number())))"
			bufi=i;
			c++;
		}//End of "for(Element *i=head; i!=NULL; i=i->next)"
	}//End of "while(check==true)"
	cout<<"Sorted";//виводимо повідомлення про успішне сортування
}
//----------------------------------------------------------------
void Stack::Fing_the_object() const//функція яка виводить номер потяга із найбільшою кількістю вагонів
{
	if(head==NULL)					//перевірка на порожність колекції
		cout<<"No trains found";//виводимо повідомлення про порожність колекції
	else
	{
		Element *max=head;//ініціалізуємо вказівник адресою голови стека
		for(Element *i=head; i!=NULL; i=i->next)//проходимо по всіх елементах стека
			if(((i->data)->get_length())>((max->data)->get_length()))//якщо кількість вагонів більша ніж у потяга на який вказує вказівник "max"
				max=i;
		cout<<"Train with a maximum number of cars: № "<<(max->data)->get_number();//виводимо номер потяга із максимальною кількістю вагонів
	}
}
//----------------------------------------------------------------
void Stack::Clean_collection()//функція для очищення колекції
{
	int size=Size();//отримуємо кількість елементів стека
	if(size==0)						//перевірка на порожність колекції
		cout<<"No trains found";//виводимо повідомлення про порожність стека
	else
	{
		for(int i=0; i<size; i++)//кількість ітерацій циклу співпадає із кількістю елементів стека
			pop();//викликаємо функцію видалення елемента
		cout<<"Cleaned";//виводимо повідомлення про успішне очищення стека
	}
}
//----------------------------------------------------------------
int  Stack::Size() const			//повертає кількість елементів колекції
{
	int size=0;// ініціалізуємо нульом змінну-лічільник для обрахунку кількості елементів
	for(Element *i=head; i!=NULL; i=i->next)//цикл проходить по всіх елементах стека
		size++;
	return size;//повертаємо кількість елементів
}
//----------------------------------------------------------------
Stack::~Stack()//деструктор
{
	Clean_collection();//викликаємо функцію очищення колекції
}